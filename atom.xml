<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>liuchuanyang前端博客</title>
  
  <subtitle>前端学习</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liuchuanyang65.github.io/"/>
  <updated>2019-12-24T06:49:34.463Z</updated>
  <id>https://liuchuanyang65.github.io/</id>
  
  <author>
    <name>刘川阳</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Node入门到实际应用</title>
    <link href="https://liuchuanyang65.github.io/Node/index/"/>
    <id>https://liuchuanyang65.github.io/Node/index/</id>
    <published>2019-12-24T15:10:51.000Z</published>
    <updated>2019-12-24T06:49:34.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NodeJS-介绍"><a href="#NodeJS-介绍" class="headerlink" title="NodeJS 介绍"></a>NodeJS 介绍</h1><h2 id="NodeJS-是什么"><a href="#NodeJS-是什么" class="headerlink" title="NodeJS 是什么"></a>NodeJS 是什么</h2><ul><li>Node.js is a <strong>JavaScript runtime</strong> built on Chrome’s V8 (不可以使用JS 全集)</li><li>Node.js uses an event-driveb, <strong>non-blocking I/O</strong> model</li></ul><h3 id="非阻塞I-O"><a href="#非阻塞I-O" class="headerlink" title="非阻塞I/O"></a>非阻塞I/O</h3><ul><li>阻塞：I/O时进程休眠等待I/O 完成后进行下一步</li><li>非阻塞：I/O时函数立即返回， 进程不等待I/O完成 </li></ul><h3 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h3><ul><li>I/O等异步操作结束后的通知</li><li>观察者模式</li></ul><h2 id="为什么偏爱NodeJs"><a href="#为什么偏爱NodeJs" class="headerlink" title="为什么偏爱NodeJs"></a>为什么偏爱NodeJs</h2><ul><li>前端职责范围变大， 统一开发体验</li><li>在处理高并发、I/O 密集场景性能优势明显</li></ul><h3 id="CPU密集-VS-I-O密集"><a href="#CPU密集-VS-I-O密集" class="headerlink" title="CPU密集 VS I/O密集"></a>CPU密集 VS I/O密集</h3><ul><li>CPU密集： 大部分时间在做计算、逻辑判断等CPU动作 （压缩、解压、加密、解密）</li></ul><ul><li>I/O密集： 大部分时间在做存取设备、网络设施的读取操作（文件操作、网络操作、数据库）<ul><li>web常见场景<ul><li>静态资源读取</li><li>数据库操作</li><li>渲染页面</li></ul></li></ul></li></ul><h3 id="高并发应对之道"><a href="#高并发应对之道" class="headerlink" title="高并发应对之道"></a>高并发应对之道</h3><ul><li>增加机器数</li><li>增加每台机器的CPU数——多核（运算能力增强）</li></ul><h3 id="相关基础知识"><a href="#相关基础知识" class="headerlink" title="相关基础知识"></a>相关基础知识</h3><ul><li>进程<ul><li>计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位</li><li>多进程：启动多个进程，多个进程可以一块执行多个任务</li></ul><ul><li>单台CPU同时可以运行多进程的原因<ul><li>类似于动画片原理，以人肉眼感知不到打速度在多个任务（进程）之间来回切换</li></ul></li></ul></li><li>线程<ul><li>进程内一个相对独立、可调度的执行单元，与同属一个进程的线程共享进程的资源</li></ul><ul><li>启动一个进程可以在进程内启动多个线程，多个线程可以一块执行多个任务</li></ul></li><li><a href="https://blog.csdn.net/huaminghui/article/details/78065810" target="_blank" rel="noopener">I/O分类及详细解释</a></li><li>NodeJs 工作模型<br><img src="/Node/index/nodejs.png" alt="NodeJs工作模型"><ul><li>单线程只开一个进程， 一个进程只开一个线程（即一个CPU上只开一个进程， 一个进程里只有一个线程）<ul><li>单线程只是针对主进程，I/O操作系统底层多线程调度（异步操作属于I/O操作系统底层多线程操作和NodeJS没有关系，NodeJS[主进程]发起一个请求，发起请求后交给I/O）</li></ul></li><li>单线程并不是单进程（CPU起几个核起几个进程）</li></ul></li><li>常用场景<ul><li>web场景，高并发、I/O密集</li><li>web server</li><li>本地代码构建</li><li>实用工具开发</li></ul></li></ul><h1 id="调试项目-amp-初始化"><a href="#调试项目-amp-初始化" class="headerlink" title="调试项目&amp;初始化"></a>调试项目&amp;初始化</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>CommonJS (模块规范)<ul><li>每个文件是一个模块，有自己作用域（模块被加载后不会再被加载，而是直接拿模块加载后的结果）</li><li>在模块内部<strong>modeule</strong>变量代表模块本身</li><li><strong>module.exports</strong> 属性代表模块对外接口</li></ul></li><li>global (没有BOM、DOM、window)<ul><li>类似于window</li><li>Buffer(二进制数据处理)、process.console</li><li>timer</li></ul></li><li>process<ul><li>process.nextTick 微任务<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2></li></ul></li><li>Inspector</li><li>VS Code</li></ul><h1 id="基础API"><a href="#基础API" class="headerlink" title="基础API"></a>基础API</h1><h2 id="path"><a href="#path" class="headerlink" title="path"></a>path</h2><ul><li>_dirname, _filename 总是返回文件的绝对路径</li><li>process.cwd() 总是返回执行node命令所在文件夹</li></ul><h2 id><a href="#" class="headerlink" title="./"></a>./</h2><ul><li>在<strong>require</strong>方法中总是相对当前文件所在文件夹</li><li>在其它地方和<strong>process.cwd()</strong>一样，相对node启动文件夹</li></ul><h2 id="Buffer-直接被挂载在global"><a href="#Buffer-直接被挂载在global" class="headerlink" title="Buffer(直接被挂载在global)"></a>Buffer(直接被挂载在global)</h2><ul><li>Buffer 用于处理二进制数据流</li><li>实例类似整数数组，大小固定（默认十六进制， 不能修改长度）</li><li>C++ 代码在V8 堆外分配物理内存</li></ul><h1 id="简单Web-Server"><a href="#简单Web-Server" class="headerlink" title="简单Web Server"></a>简单Web Server</h1><p>使用了<strong>supervisor</strong>监听文件改变<br>使用了<strong>handlebars</strong>模板引擎<br>使用了<strong><a href="http://www.ruanyifeng.com/blog/2019/09/curl-reference.html" target="_blank" rel="noopener">curl</a></strong>模拟请求web服务器(mac 自带)<br>使用<strong>commander或者yargs</strong>获取命令行参数列表</p><h2 id="实现一个静态资源服务器"><a href="#实现一个静态资源服务器" class="headerlink" title="实现一个静态资源服务器"></a>实现一个静态资源服务器</h2><p>执行命令可以把本地的当前目录变成一个静态资源服务器的根目录，可以通过url访问文件（<strong>anywhere</strong>）</p><h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><ul><li>实现对文件的读写，并在对应的Host:port 打开</li><li>设置npm 配置并上传到npm 生成npm cli </li></ul><h3 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h3><ul><li>匹配模式前/: 代表项目根目录</li><li>匹配模式最后加/: 代表是目录</li><li>匹配模式前加!: 代表取反</li><li>*： 代表任意个字符</li><li>？： 匹配任意一个字符 </li><li>**: 匹配多级目录</li></ul><h3 id="npmignore"><a href="#npmignore" class="headerlink" title=".npmignore"></a>.npmignore</h3><p><a href="https://docs.npmjs.com/misc/developers" target="_blank" rel="noopener">.npmignore详细说明</a></p><h3 id="EditorConfig"><a href="#EditorConfig" class="headerlink" title="EditorConfig"></a><a href="https://editorconfig.org/" target="_blank" rel="noopener">EditorConfig</a></h3><h3 id="对文件设置range"><a href="#对文件设置range" class="headerlink" title="对文件设置range"></a>对文件设置range</h3><ul><li>requestHeader设置<ul><li>range: bytes=[start]-[end]</li></ul></li><li>responseHeader设置<ul><li>Accept-Range: bytes</li><li>Content-Range: bytes start-end/total</li></ul></li></ul><h3 id="缓存header"><a href="#缓存header" class="headerlink" title="缓存header"></a>缓存header</h3><ul><li>responseHeader<ul><li>expirse(返回绝对时间)</li><li>cache-control(返回上次请求的相对时间max-age)</li></ul></li><li>If-Modified-Since / Last-Modified(一对)<ul><li>requestHeader: If-Modified-Since</li><li>responseHeader: Last-Modified</li></ul></li><li>if-None-Match / ETag<br><img src="/Node/index/cache.png" alt="浏览器请求缓存流程"></li></ul><h3 id="语义化版本号-x-y-z"><a href="#语义化版本号-x-y-z" class="headerlink" title="语义化版本号 x.y.z"></a>语义化版本号 x.y.z</h3><ul><li>升级z位： bug fix</li><li>升级y位： 有新增功能并且和之前兼容同时bug fix</li><li>升级x位： 不保证兼容（一般偶数为稳定版）</li><li>x.y.*:<ul><li>如1.2.*：自动更新z位，bug fix为最新 与 ~1.2.0相同</li><li>x/y固定</li></ul></li><li>x.x 如： 2.x 与 ^2.0.0</li></ul><p><strong>linux系统需要给文件添加操作权限</strong></p><h1 id="本地构建"><a href="#本地构建" class="headerlink" title="本地构建"></a>本地构建</h1><ul><li>压缩</li><li>less/scss等构建为css、ES5/ES6构建为浏览器可识别的版本等</li></ul><h1 id="单元测试-amp-发布"><a href="#单元测试-amp-发布" class="headerlink" title="单元测试 &amp; 发布"></a>单元测试 &amp; 发布</h1><h1 id="NodeJS-爬虫示例"><a href="#NodeJS-爬虫示例" class="headerlink" title="NodeJS 爬虫示例"></a>NodeJS 爬虫示例</h1>]]></content>
    
    <summary type="html">
    
      本篇主要深入理解讲解Node入门到实际应用
    
    </summary>
    
      <category term="Node" scheme="https://liuchuanyang65.github.io/categories/Node/"/>
    
    
      <category term="Node" scheme="https://liuchuanyang65.github.io/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>dataStructure</title>
    <link href="https://liuchuanyang65.github.io/dataStructure/index/"/>
    <id>https://liuchuanyang65.github.io/dataStructure/index/</id>
    <published>2019-09-03T17:55:25.000Z</published>
    <updated>2019-09-03T10:00:37.716Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法基础"><a href="#算法基础" class="headerlink" title="算法基础"></a>算法基础</h2><h3 id="衡量标准"><a href="#衡量标准" class="headerlink" title="衡量标准"></a>衡量标准</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2>]]></content>
    
    <summary type="html">
    
      本篇主要介绍了是数据结构和算法
    
    </summary>
    
      <category term="数据结构" scheme="https://liuchuanyang65.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://liuchuanyang65.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>interviewQuestion</title>
    <link href="https://liuchuanyang65.github.io/interviewQuestion/index/"/>
    <id>https://liuchuanyang65.github.io/interviewQuestion/index/</id>
    <published>2019-08-22T18:39:19.000Z</published>
    <updated>2019-09-02T02:43:04.228Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h4 id="转Boolean类型"><a href="#转Boolean类型" class="headerlink" title="转Boolean类型"></a>转Boolean类型</h4><p>在条件判断中，除了 undefined， null， false， NaN， ‘’， 0， -0，其他所有值都转为 true，包括所有对象。<br><strong>只是在条件判断中 undefined， null， false， NaN， ‘’， 0， -0可以当falses使用，并不意味着*==false为true(下面会详细讲解)</strong></p><h4 id="对象转基本类型"><a href="#对象转基本类型" class="headerlink" title="对象转基本类型"></a>对象转基本类型</h4><ul><li>对象在转基本类型的时候，首先会调用valueOf方法。</li></ul><h3 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h3><h4 id="写一个原型链继承的例子"><a href="#写一个原型链继承的例子" class="headerlink" title="写一个原型链继承的例子"></a>写一个原型链继承的例子</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Elem</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.elem = <span class="built_in">document</span>.getElementById(<span class="string">'id'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Elem.prototype.html = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> elem = <span class="keyword">this</span>.elem</span><br><span class="line">  <span class="keyword">if</span> (val) &#123;</span><br><span class="line">    elem.html = val</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> elem.html</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Elem.propotype.on = <span class="function"><span class="keyword">function</span> (<span class="params">type, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> elem = <span class="keyword">this</span>.elem</span><br><span class="line">  elem.addEventListener(type, fn)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div1 = <span class="keyword">new</span> Elem(<span class="string">'div1'</span>) <span class="comment">// div1._proto_ = Elem.prototype</span></span><br><span class="line"></span><br><span class="line">div1.html(<span class="string">'插入文本'</span>)</span><br><span class="line"></span><br><span class="line">div1.on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'绑定事件'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于每一个原型方法中都返回了this 故可进行原型操作如下：</span></span><br><span class="line">div1.html(<span class="string">'插入文本'</span>).on(<span class="string">'click'</span>, funtion() &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'绑定事件'</span>)</span><br><span class="line">&#125;).html() <span class="comment">// 插入文本</span></span><br></pre></td></tr></table></figure><h4 id="描述new一个对象的过程"><a href="#描述new一个对象的过程" class="headerlink" title="描述new一个对象的过程"></a>描述new一个对象的过程</h4><ul><li>创建了一个新对象</li><li>把obj._proto_指向 Obj.prototype实现继承</li><li>执行构造函数、传递参数、改变this指向</li><li>返回obj给新变量</li></ul><p>example:</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生 new</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype.bark = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'wangwang'</span>)</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'my name is'</span> + <span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Dog(<span class="string">'dog'</span>)</span><br><span class="line">dog.bark() <span class="comment">// wangwang</span></span><br><span class="line">dog.sayName() <span class="comment">// my name is dog</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  自行编写一个简单的new</span></span><br><span class="line"><span class="keyword">var</span> _new = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> constructor = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>) <span class="comment">// 取第一个参数及构造函数</span></span><br><span class="line">  <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">  <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">  obj._proto_ = constructor.prototype</span><br><span class="line">  constructor.apply(obj, args)</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat = _new(Dog, <span class="string">'cat'</span>)</span><br><span class="line">cat.bark()</span><br><span class="line">cat.sayName()</span><br></pre></td></tr></table></figure><h4 id="原型的规则"><a href="#原型的规则" class="headerlink" title="原型的规则"></a>原型的规则</h4><ul><li>所有的引用类型(数组、对象、函数)，都具有对象特性，且具有自由可扩展属性</li><li>所有的引用类型（数组、对象、函数），都有一个_proto_（隐式原型）属性，属性值是一个普通的对象（浏览器自己创建）</li><li>所有的函数，都有一个prototype（显示原型）属性，属性值也是一个普通的对象（浏览器自己创建）</li><li>所有的引用类型（数组、对象、函数），_proto_属性值指向它的构造函数“prototype”属性值</li><li>当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去他的——proto_（即它的构造函数的prototype）中寻找</li></ul><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p><strong>instanceof用于判断属于哪个构造函数的方法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = []</span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// true</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true </span></span><br><span class="line"><span class="comment">// 由于所有的引用类型均有隐式原型且指向构造函数的显示原型，隐式原型和显示原型又均为对象，原型链可以一直指向Object.prototype._proto_ =&gt; null</span></span><br></pre></td></tr></table></figure><h3 id="作用域与闭包"><a href="#作用域与闭包" class="headerlink" title="作用域与闭包"></a>作用域与闭包</h3><p>闭包在实际开发中主要应用于收敛权限、封装变量<br>在了解这部分之前先了解一下 this、执行上下文、执行站（内存堆、调用栈）</p><h3 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a>防抖与节流</h3><p>防抖和节流的作用都是防止函数多次调用。<br><strong>区别在于：假设一个用户一直触发这个函数，且每次触发函数的间隔小于wait,防抖的情况只会调用一次，而节流的情况每个一定时间（参数wait）调用函数</strong></p><h2 id="Eventloop"><a href="#Eventloop" class="headerlink" title="Eventloop"></a>Eventloop</h2><p>不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise'</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br><span class="line"><span class="comment">// script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout</span></span><br></pre></td></tr></table></figure><ul><li><p>微任务包括 process.nextTick ，promise ，Object.observe ，MutationObserver</p></li><li><p>宏任务包括 script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering</p></li></ul><p>很多人有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 script ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务。</p><p>所以正确的一次 Event loop 顺序是这样的</p><ul><li>(1) 执行同步代码，这属于宏任务</li><li>(2) 执行栈为空，查询是否有微任务需要执行</li><li>(3) 执行所有微任务</li><li>(4) 必要的话渲染 UI</li><li>(5) 然后开始下一轮 Event loop，执行宏任务中的异步代码</li></ul><h2 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h2><p><a href="https://www.cnblogs.com/nnngu/p/9347635.html" target="_blank" rel="noopener">websocket原理</a></p><h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><p>Ajax的全称是Asynchronous JavaScript and XML (异步的JavaScript 和 XML)，有别于传统web开发中采用的同步方式。</p><h3 id="关于同步和异步"><a href="#关于同步和异步" class="headerlink" title="关于同步和异步"></a>关于同步和异步</h3><ul><li>异步传输是面向字符的传输，单位是字符。</li><li>同步传输是面向比特的传输，单位是帧，传输时客户端和服务器端的时间一致。</li></ul><h3 id="ajax所包含的技术"><a href="#ajax所包含的技术" class="headerlink" title="ajax所包含的技术"></a>ajax所包含的技术</h3><ul><li>使用CSS和XHTML来表示</li><li>使用DOM模型来交互和动态显示</li><li>使用XMLHttpRequest来和服务器进行一步通信</li><li>使用javascript来绑定和调用</li></ul><p>ajax相当于在用户和服务器之间加了一个中间层，使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器，类似于一些数据验证和数据处理等都交给Ajax引擎自己来做，只有确定需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求。</p><p><strong>Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发送异步请求，从服务器活的数据，然后用js来操作DOM进行页面更新。XMLHttpRequest是ajax的核心机制。</strong></p><p>Example:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、创建XMLHttpRequest对象</span></span><br><span class="line"><span class="selector-tag">var</span> xhr = new XMLHttpRquest()</span><br><span class="line"><span class="comment">// 2、设置请求方式</span></span><br><span class="line">xhr.open(<span class="string">"GET"</span>, <span class="string">"/api"</span>, true) <span class="comment">// 异步</span></span><br><span class="line"><span class="comment">// 3、调用回调函数</span></span><br><span class="line">xhr<span class="selector-class">.onreadystatechange</span> = function () &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr<span class="selector-class">.readyState</span> == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr<span class="selector-class">.status</span> == <span class="number">200</span>) &#123;</span><br><span class="line">      console.log(xhr.reponseText)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4、设置发送请求的内容和发送报文，紧接着发送请求</span></span><br><span class="line">xhr.send() <span class="comment">// POST 请求数据是放在send里面</span></span><br></pre></td></tr></table></figure><ul><li><p>状态码说明</p></li><li><p>（1）readyState<br>0: （尚未初始化）还没有调用send()方法<br>1: （载入）已调用send()方法，正在发送请求<br>2: （载入完成）send()方法执行完成，已经接收到全部响应内容<br>3:  (交互)正在解析响应内容<br>4:  (完成) 响应内容解析完成，可以在客户端调用</p></li><li><p>（2）status<br>2XX、3XX、4XX、5XX</p></li></ul><h3 id="ajax的优缺点"><a href="#ajax的优缺点" class="headerlink" title="ajax的优缺点"></a>ajax的优缺点</h3><ul><li>优点：</li><li>（1）无刷新更新数据： AJAX最大的有点就是能在不刷新整个页面的前提下与服务器通信并维护数据。使Web应用程序更为迅捷的响应用户交互，并避免在网上发送没有用的信息，减少用户等待时间，增强用户体验。</li><li>（2）异步与服务器通信</li><li>（3）前端和后端负载平衡： AJAX可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和贷款的负担，节约空间和带宽租用成本。<em>**AJAX的原则是“按需取数据”</em></li><li>（4）基于标准被广泛支持</li><li>（5）界面与应用分离<br>缺点：</li><li>（1）AJAX干掉了Back和History功能，即对浏览器机制的破坏：在动态更新页面的情况下，用户无法回到前一个页面状态，因为浏览器仅能计息历史记录中的静态页面。一个完整读入的页面与一个一杯动态修改过的页面之间的差别非常微妙。</li><li>（2）AJAX安全问题</li><li>（3）破坏程序的异常处理机制</li></ul><h3 id="Promise-Promise-是ES6新增的语法，解决了回调地狱的问题"><a href="#Promise-Promise-是ES6新增的语法，解决了回调地狱的问题" class="headerlink" title="Promise(Promise 是ES6新增的语法，解决了回调地狱的问题)"></a>Promise(Promise 是ES6新增的语法，解决了回调地狱的问题)</h3><p>可以把Promise看成一个状态机。初始值是pending, 可以通过函数resolve 和 reject, 将状态转变为resolved或者rejected状态，状态一旦改变不能再次变化。</p><p>then 函数会返回一个Promise实例，并且该返回值是一个新的实例而不是之前的实例。因为Promise规范规定除了pending状态，其他状态是不可改变的，如果返回的是一个相同实例的话，多个then调用就是去意义了。</p><p><strong>一个简易版手写Promise：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">"pending"</span></span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">"resolved"</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">"rejected"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line">  <span class="comment">// promise 的初始值是pending</span></span><br><span class="line">  that.curentState = PENDING</span><br><span class="line">  <span class="comment">// 用于保存resolve 或者 reject 中传入的值</span></span><br><span class="line">  that.value = <span class="string">''</span></span><br><span class="line">  <span class="comment">// 用于保存then中的回调</span></span><br><span class="line">  that.resolvedCallbacks = []</span><br><span class="line">  that.rejectedCallbacks = []</span><br><span class="line"></span><br><span class="line">  that.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">      <span class="comment">// 如果value 是个Promise， 递归执行</span></span><br><span class="line">      <span class="keyword">return</span> value.then(that.resolve, that.reject)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异步执行 保证执行顺序</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (that.currentState  === PENDING) &#123;</span><br><span class="line">        that.currentState = REJECTED</span><br><span class="line">        that.value = value</span><br><span class="line">        that.resolvedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  that.reject = <span class="function"><span class="keyword">function</span> (<span class="params">reson</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (that.currentState === PENDING) &#123;</span><br><span class="line">        that.currentState = REJECTED</span><br><span class="line">        that.value = reason</span><br><span class="line">        that.rejectedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于解决new Promise(() =&gt; throw Error('error'))</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fn(that.resolve, that.reject)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    that.reject(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromoise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">  <span class="comment">// 必须返回一个新的Promise</span></span><br><span class="line">  <span class="keyword">var</span> promiseN</span><br><span class="line">  <span class="comment">// onFulfilled onRejected都为可选参数</span></span><br><span class="line">  <span class="comment">// 如果类型不是函数需要忽略， 同是也实现了透传</span></span><br><span class="line">  onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">v</span> =&gt;</span> v</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">r</span> =&gt;</span> <span class="keyword">throw</span> r</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.currentState === RESOLVED || self.currentState === REJECTED) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">promiseN = <span class="keyword">new</span> MyPromise(<span class="params">(<span class="params">resolve, reject</span>) =&gt; &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      setTimeout(<span class="params">(<span class="params"></span>) =&gt; &#123;</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">        <span class="keyword">try</span> &#123;</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">          resolve(<span class="params">self.value</span>)</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">        &#125; <span class="keyword">catch</span> (<span class="params">reason</span>) &#123;</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">          reject(<span class="params">reason</span>)</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">        &#125;</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">      &#125;</span>)</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">    &#125;</span>)</span>)</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="params">if</span> (<span class="params">self.currentState === PENDING</span>) &#123;</span></span><br><span class="line"><span class="function">    <span class="params">return</span> (<span class="params">promiseN = <span class="keyword">new</span> MyPromise(<span class="params">(<span class="params">resolve, reject</span>) =&gt; &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      self.resolvedCallbacks.push(<span class="params">(<span class="params"></span>) =&gt; &#123;</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">        <span class="keyword">try</span> &#123;</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">          resolve(<span class="params">self.value</span>)</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">        &#125; <span class="keyword">catch</span> (<span class="params">r</span>) &#123;</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">          reject(<span class="params">r</span>)</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">        &#125;</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">      &#125;</span>)</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      self.rejectedCallbacks.push(<span class="params">(<span class="params"></span>) =&gt; &#123;</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">        <span class="keyword">try</span> &#123;</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">          resolve(<span class="params">self.value</span>)</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">        &#125; <span class="keyword">catch</span> (<span class="params">r</span>) &#123;</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">          reject(<span class="params">r</span>)</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">        &#125;</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">      &#125;</span>)</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">    &#125;</span>)</span>)</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>// flatten</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flatten = <span class="function"><span class="params">array</span> =&gt;</span> array.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> (<span class="built_in">Array</span>.isArray(cur) ? [...acc, ...flatten(cur)] : [...acc, cur]), [])</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> flatten = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (arr.some(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">Array</span>.isArray(item))) &#123;</span><br><span class="line">        arr = [].concat(...arr)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arrs = [];</span><br><span class="line">  arr.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(item))&#123;</span><br><span class="line">      arrs.push(... flatten(item))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      arrs.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> arrs</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 迭代实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arrs =[...arr]</span><br><span class="line">  <span class="keyword">let</span> newArr = [];</span><br><span class="line">  <span class="keyword">while</span> (arrs.length)&#123;</span><br><span class="line">    <span class="keyword">let</span> item = arrs.shift()</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(item))&#123;</span><br><span class="line">      arrs.unshift(...item)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      newArr.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 字符串实现</span></span><br><span class="line">arr.join(<span class="string">','</span>).split(<span class="string">','</span>).map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">Number</span>(item)))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      本篇文章主要简单介绍了在面试中会经常遇到的问题。
    
    </summary>
    
      <category term="前端面试" scheme="https://liuchuanyang65.github.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端面试" scheme="https://liuchuanyang65.github.io/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 状态码</title>
    <link href="https://liuchuanyang65.github.io/httpStatusCode/index/"/>
    <id>https://liuchuanyang65.github.io/httpStatusCode/index/</id>
    <published>2019-08-19T15:10:51.000Z</published>
    <updated>2019-08-27T11:06:29.317Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在开篇之前先简单介绍一下状态码，HTTP状态码是当客户端像服务端发送请求时，描述返回的请求结果。通过状态码，用户可以知道服务器端是正常处理了请求还是出现了错误。</p><ul><li>状态码如： 200 OK， <strong>由3个数字和原因短语组成</strong></li></ul><ol><li>1XX： 信息性状态码          接受的请求正在处理</li><li>2XX： 成功状态码            请求正常处理完毕</li><li>3XX： 重定向状态码          需要进行附加操作已完成请求</li><li>4XX： 客户端错误状态码       服务器无法处理请求</li><li>5XX： 服务器错误状态码       服务器处理请求出错</li></ol><h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><p>用于HTTP协议交互的信息被称为HTTP报文。请求端（客户端）的HTTP 报文叫做请求报文，响应端（服务器端）的叫做响应报文。<br>HTTP 报文大致可分为报文首部和报文主体两块。</p><p><strong>报文和实体的区别：</strong></p><ul><li>报文： 是HTTP通信的基本单位，由8位组字节流组成，通过HTTP通信传输。</li><li>实体： 作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。</li></ul><h3 id="2XX"><a href="#2XX" class="headerlink" title="2XX"></a>2XX</h3><p>2XX的响应结果表明请求被正常处理了</p><ol><li><p>200OK：<br>表示从客户端发来的请求在服务器端被正常处理了。</p></li><li><p>204 No Content：<br>表示服务器接收的请求已成功处理，但在返回的报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。一般在只需要从客户端往服务器端发送信息，而对客户端不需要发送新信息内容的情况下使用</p></li></ol><p><strong>example:</strong> 当从浏览器发出请求处理后，返回 204 响应，那么浏览器显示的页面不发生更新。</p><ol start="3"><li>206 Partial Conte<br>表示客户端进行了范围请求，而服务器成功执行了这部分的GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。</li></ol><h3 id="3XX"><a href="#3XX" class="headerlink" title="3XX"></a>3XX</h3><p>3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。</p><ol><li><p>301 Moved Permanent：<br>永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URL。也就是说，如果已经把资源对应的 URL保存为书签了，这时应该按 Location 首部字段提示的 URL 重新保存。</p></li><li><p>302 Found：<br>临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户<strong>本次</strong>能使用新的 URL 访问。</p></li></ol><ul><li>和 301 Moved Permanently 状态码相似，但 302 状态码代表的资源不是被永久移动，只是临时性质的。换句话说，已移动的资源对应的URL 将来还有可能发生改变。比如，用户把 URL 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URL。</li></ul><ol start="3"><li>303 See Other：<br>该状态码表示由于请求对应的资源存在着另一个 URL，应使用 GET 方法定向获取请求的资源。</li></ol><ul><li><p>303 状态码和 302 Found 状态码有着相同的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区别。</p></li><li><p>当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送。</p></li><li><p>301、302 标准是禁止将 POST 方法改变成 GET 方法的，但实际使用时大家都会这么做</p></li></ul><ol start="3"><li>304 Not Modified：</li></ol><p>该状态码表示客户端发送附带条件的请求 时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。如：协商缓存发送请求，缓存有效时返回304。<strong>304 虽然被划分在 3XX 类别中，但是和重定向没有关系</strong>。</p><ol start="4"><li>307 Temporary Redirect：<br>临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标准 禁止 POST 变换成 GET，但实际使用时大家并不遵守。</li></ol><p>307 会遵照浏览器标准，不会从 POST 变成 GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况。</p><h3 id="4XX"><a href="#4XX" class="headerlink" title="4XX"></a>4XX</h3><p>4XX 的响应结果表明客户端是发生错误的原因所在。</p><ol><li><p>400 Bad Reque:<br>该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。</p></li><li><p>401 Unauthorized：<br>该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。另外若之前已进行过 1 次请求，则表示用户认证失败。</p></li><li><p>403 Forbidden：<br>该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。</p></li><li><p>404 Not Found：<br>该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。</p></li></ol><h3 id="5XX"><a href="#5XX" class="headerlink" title="5XX:"></a>5XX:</h3><p>5XX 的响应结果表明服务器本身发生错误。</p><ol><li><p>500 Internal Server Error<br>该状态码表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的bug或某些临时的故障。</p></li><li><p>503 Service Unavailable<br>该状态码表明服务器暂时处于超负载或正在进行停机维护们现在无法处理请求。</p></li></ol>]]></content>
    
    <summary type="html">
    
      本篇主要介绍了HTTP 状态码
    
    </summary>
    
      <category term="HTTP" scheme="https://liuchuanyang65.github.io/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="https://liuchuanyang65.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>深入理解HTTP</title>
    <link href="https://liuchuanyang65.github.io/http/index/"/>
    <id>https://liuchuanyang65.github.io/http/index/</id>
    <published>2019-08-19T15:10:51.000Z</published>
    <updated>2019-12-12T02:15:28.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解HTTP"><a href="#深入理解HTTP" class="headerlink" title="深入理解HTTP"></a>深入理解HTTP</h1><p><img src="/http/index/url.png" alt="浏览器输入URL后HTTP请求返回的完整过程"></p><h1 id="网络协议基础知识"><a href="#网络协议基础知识" class="headerlink" title="网络协议基础知识"></a>网络协议基础知识</h1><h2 id="网络协议分层"><a href="#网络协议分层" class="headerlink" title="网络协议分层"></a>网络协议分层</h2><h3 id="经典五层模型"><a href="#经典五层模型" class="headerlink" title="经典五层模型"></a>经典五层模型</h3><p><img src="/http/index/five_model.png" alt="经典五层模型"></p><ul><li><p>低三层：</p><ul><li>物理层主要作用是定义物理设备如何传输数据</li><li>数据链路层在通信的实体间建立数据链路连接</li><li>网络层为数据在结点之间传输创建逻辑链路</li></ul></li><li><p><strong>传输层：</strong></p><ul><li>向用户提供可靠的端到端（End-to-End）服务</li><li>传输层向高层（即应用层）屏蔽了下层数据通信的细节</li></ul></li><li><p><strong>应用层：</strong></p><ul><li>为应用软件提供了很多服务</li><li>构建于TCP协议之上</li><li>屏蔽网络传输相关细节</li></ul></li></ul><h2 id="HTTP协议的发展历史"><a href="#HTTP协议的发展历史" class="headerlink" title="HTTP协议的发展历史"></a>HTTP协议的发展历史</h2><h3 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h3><ul><li>只有一个命令GET</li><li>没有HEADER等描述数据的信息</li><li>服务器发送完毕，就关闭TCP连接（此处连接与HTTP不同，HTTP请求与TCP连接不是同一个概念， 在一个TCP连接发送很多个HTTP请求，HTTP请求存在于某一个TCP连接）</li></ul><h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h3><ul><li>增加了很多命令（POST/PUT）</li></ul><ul><li>增加status code 和 header<ul><li>status code 是用来描述服务端处理某一个请求之后的状态</li><li>header 对应的请求的描述</li></ul></li></ul><ul><li>多字符集支持、多部分发送、权限、缓存等</li></ul><h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h3><ul><li>持久连接<ul><li>在1.0版本中一个HTTP请求就要在客户端和服务端创建一个TCP连接，在服务端返还完内容后该TCP连接相对应关闭（成本相对较高、消耗、延迟）</li></ul></li><li>pipeline<ul><li>可以在一个连接中发送多个请求，但是响应时按照先后顺序</li></ul></li><li>增加Host 和 其他一些命令<ul><li>在同一个物理服务器中或者同一个集群里面可以部署很多不同的web服务（提高使用效率）</li></ul></li></ul><h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP/2.0"></a>HTTP/2.0</h3><ul><li>所用数据以二进制进行传输<ul><li>HTTP 1大部分数据传输是通过字符串，数据分片方式不同 </li></ul></li><li>同一个连接里面发送多个请求不再需要按照顺序来返回处理，可同时返回多个（并行）</li><li>头信息压缩以及推送等提高效率的功能<ul><li>服务端可以主动发起数据传输</li></ul></li></ul><h2 id="HTTP-三次握手"><a href="#HTTP-三次握手" class="headerlink" title="HTTP 三次握手"></a>HTTP 三次握手</h2><p><img src="/http/index/tcp_connect.png" alt="HTTP请求的TCP连接基础"></p><p><img src="/http/index/three.png" alt="TCP三次握手"></p><h2 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h2><h2 id="HTTP客户端"><a href="#HTTP客户端" class="headerlink" title="HTTP客户端"></a>HTTP客户端</h2><h2 id="CORS跨域限制以及预请求验证"><a href="#CORS跨域限制以及预请求验证" class="headerlink" title="CORS跨域限制以及预请求验证"></a>CORS跨域限制以及预请求验证</h2><h3 id="CORS跨域允许方法、content-type-否则会进行预请求验证后才发送"><a href="#CORS跨域允许方法、content-type-否则会进行预请求验证后才发送" class="headerlink" title="CORS跨域允许方法、content-type(否则会进行预请求验证后才发送)"></a>CORS跨域允许方法、content-type(否则会进行预请求验证后才发送)</h3><h4 id="跨域允许方法"><a href="#跨域允许方法" class="headerlink" title="跨域允许方法"></a>跨域允许方法</h4><ul><li>GET</li><li>header</li><li>POST</li></ul><h4 id="跨域允许Content-Type"><a href="#跨域允许Content-Type" class="headerlink" title="跨域允许Content-Type"></a>跨域允许Content-Type</h4><ul><li>text/plain</li><li>multipart/form-data</li><li>application/x-www-form-urlencoded</li></ul><h4 id="其他限制"><a href="#其他限制" class="headerlink" title="其他限制"></a>其他限制</h4><ul><li>请求头限制<ul><li>自定义请求头（不被允许但是可以通过设置Access-Control-Allow-*允许访问）<br>  Allow-Origin: 允许域<br>  Allow-Headers: 允许自定义Header<br>  Allow-Methods: 允许方法<br>  Max-Age: 最大允许访问时间（时间内不会再发送预请求）</li><li>其他请求头限制(cors-safelisted-request-header)[<a href="https://fetch.spec.whatwg.org/]" target="_blank" rel="noopener">https://fetch.spec.whatwg.org/]</a></li></ul></li></ul><ul><li>XMLHttpRequestUpload 对象均没有注册任何时间监听器</li><li>请求中没有使用ReadableStream对象</li></ul><h3 id="预请求"><a href="#预请求" class="headerlink" title="预请求"></a>预请求</h3><h2 id="缓存头Cache-Control"><a href="#缓存头Cache-Control" class="headerlink" title="缓存头Cache-Control"></a>缓存头Cache-Control</h2><h3 id="可缓存性（哪里地方可缓存）"><a href="#可缓存性（哪里地方可缓存）" class="headerlink" title="可缓存性（哪里地方可缓存）"></a>可缓存性（哪里地方可缓存）</h3><ul><li>public<ul><li>均可缓存（包括中间Http代理服务器、发出请求客户端浏览器，http请求经过的地方）</li></ul></li><li>private<ul><li>发出请求的客户端</li></ul></li><li>no-cache<ul><li>可以缓存，但需要服务器验证</li></ul></li></ul><h3 id="到期"><a href="#到期" class="headerlink" title="到期"></a>到期</h3><ul><li><p>max-age = <seconds></seconds></p></li><li><p>s-maxage = <seconds></seconds></p><ul><li>在代理服务器中会覆盖 max-age</li></ul></li><li><p>max-stale = <seconds></seconds></p><ul><li>即便max-age已经过期，但是客户端在max-sale时间内便可使用max-age已过期的缓存，而不用重新去服务器端请求</li></ul></li></ul><h3 id="重新验证"><a href="#重新验证" class="headerlink" title="重新验证"></a>重新验证</h3><ul><li>must-revalidate</li><li>proxy-revalidate<ul><li>缓存服务器重新验证</li></ul></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>no-store<ul><li>彻底不缓存</li></ul></li><li>no-transform</li></ul><h2 id="资源验证"><a href="#资源验证" class="headerlink" title="资源验证"></a>资源验证</h2><p><img src="/http/index/%E8%B5%84%E6%BA%90%E9%AA%8C%E8%AF%81.png" alt="资源验证"></p><h3 id="验证头"><a href="#验证头" class="headerlink" title="验证头"></a>验证头</h3><ul><li>Last-Modified<ul><li>上次修改时间</li><li>配合If-Modified-Since或者If-Unmodified-Since 使用</li><li>对比上次修改时间查看是否需要更新</li></ul></li><li>Etag<ul><li>数据签名</li><li>配合If-Match 或者 If-Non-Match使用</li><li>对比资源签名判断是否使用缓存</li></ul></li></ul><h2 id="cookie-和-session"><a href="#cookie-和-session" class="headerlink" title="cookie 和 session"></a>cookie 和 session</h2><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><h4 id="cookie-1"><a href="#cookie-1" class="headerlink" title="cookie"></a>cookie</h4><ul><li>通过Set-Cookie设置到浏览器，下次再同域的请求中浏览器会自动携带</li><li>键值对，可以设置多个</li></ul><h4 id="cookie属性"><a href="#cookie属性" class="headerlink" title="cookie属性"></a>cookie属性</h4><ul><li>max-age 和 expires 设置过期时间</li><li>secure 只在https的时候发送</li><li>HttpOnly 无法通过document.cookie 访问（安全性）</li></ul><h2 id="HTTP长连接"><a href="#HTTP长连接" class="headerlink" title="HTTP长连接"></a>HTTP长连接</h2><h2 id="数据协商"><a href="#数据协商" class="headerlink" title="数据协商"></a>数据协商</h2><h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><ul><li>Accept<ul><li>Accept</li><li>Accept-Encoding: 数据压缩算法gzip, deflate</li><li>Accept-Language</li><li>User-Agent: 判断客户端浏览器环境、设备类型<h3 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h3></li></ul></li><li>Content<ul><li>Content-Type</li><li>Content-Encoding</li><li>Content-Language</li></ul></li></ul><h2 id="Redirect"><a href="#Redirect" class="headerlink" title="Redirect"></a>Redirect</h2><ul><li>返回302，服务端Header设置, 临时跳转<ul><li>Location</li><li>Host</li></ul></li><li>返回301，服务端Header设置, 永久跳转<ul><li>指定了新的地址后，再次访问时浏览器会直接将旧地址变成新的路径（浏览器尽量缓存链接301状态），不需要经过服务器指定新的Location</li></ul></li></ul><h2 id="CSP-Content-Security-Policy"><a href="#CSP-Content-Security-Policy" class="headerlink" title="CSP(Content-Security-Policy)"></a>CSP(Content-Security-Policy)</h2><ul><li>作用<ul><li>限制资源获取</li><li>报告资源获取越权</li></ul></li><li>限制方式<ul><li>default-src 限制全局</li><li>限定资源类型</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      本篇主要深入理解HTTP并实践
    
    </summary>
    
      <category term="HTTP" scheme="https://liuchuanyang65.github.io/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="https://liuchuanyang65.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>this的全面解析</title>
    <link href="https://liuchuanyang65.github.io/this/index/"/>
    <id>https://liuchuanyang65.github.io/this/index/</id>
    <published>2019-08-12T09:05:49.000Z</published>
    <updated>2019-10-28T01:46:32.524Z</updated>
    
    <content type="html"><![CDATA[<p>this的默认绑定规则总共与下面五种：</p><ul><li>默认绑定（严格/非严格）</li><li>隐式绑定</li><li>显示绑定</li><li>new绑定</li><li>箭头函数绑定</li></ul><h1 id="调用位置"><a href="#调用位置" class="headerlink" title="调用位置"></a>调用位置</h1><p>什么是调用位置？</p><ul><li>调用位置： 函数在代码中被调用的位置（而不是函数声明的位置）</li></ul><p>查找方法：</p><ul><li>分析调用栈： 调用位置就是当前正在执行的函数的<strong>前一个调用</strong>中</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当前调用栈是： a</span></span><br><span class="line">    <span class="comment">// 因此， 当前调用位置是全局作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a'</span>)</span><br><span class="line">    b() <span class="comment">// b 的调用位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当前调用栈是： a --&gt; b</span></span><br><span class="line">    <span class="comment">// 因此，当前调用位置在a 中</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'b'</span>)</span><br><span class="line">    c() <span class="comment">// c 的调用位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当前调用栈是： a --&gt; b --&gt; c</span></span><br><span class="line">    <span class="comment">// 因此，当前调用位置在b中</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'c'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a(); <span class="comment">// a 的调用位置</span></span><br></pre></td></tr></table></figure><ul><li>使用开发者工具<br>设置断点，展示当前位置的函数调用列表（call stack）即<strong>调用栈</strong>，找到栈中的<strong>第二个元素</strong>，这就是真正的调用位置。</li></ul><h1 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h1><h2 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h2><ul><li><strong>独立函数调用</strong>，可以把默认绑定看做是无法运用其他规则时的默认规则，<strong>this指向全局对象</strong></li><li><strong>严格模式</strong>下，不能将全局对象用于默认绑定，this会绑定到undefined。但是在严格模式下进行<strong>函数调用</strong>不影响this默认绑定，即this可以绑定到全局对象。只有在非严格模式下，this才能绑定到全局对象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ex</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">ex(); <span class="comment">//TypeError: Cannot read property 'a' of undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*======================================*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ex</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line"></span><br><span class="line">    ex();</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h2 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h2><p>当函数引用有上下文时，隐式绑定规则会把函数中的this绑定到这个上下文对象。对象属性引用链只有上一层或者说是最后一层在调用中起作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ex</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    ex: ex</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.ex(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h3><p>被隐式绑定的函数在特定情况下会丢失绑定对象，应用默认绑定，把this绑定到全局对象或者undefined上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ex</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    ex: ex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> exT = obj.ex;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"this global"</span>; <span class="comment">// a是全局对象的属性</span></span><br><span class="line"></span><br><span class="line">exT(); <span class="comment">// this global</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 虽然exT是obj.ex的一个引用, 但是实际上， 它引用的是ex函数本身</span></span><br><span class="line"><span class="comment">// exT()是一个不带任何修饰的函数调用， 应用默认绑定</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ex</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doEx</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// fn 其实引用的是ex</span></span><br><span class="line"></span><br><span class="line">    fn(); <span class="comment">// 调用位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    ex: ex</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"this global"</span>;</span><br><span class="line"></span><br><span class="line">doEx(obj.ex); <span class="comment">// this global</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ======================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// JS 环境中内置的setTimeout()函数和上面的伪代码类似：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setTimeout</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 等待 delay毫秒</span></span><br><span class="line">    fn(); <span class="comment">// 调用位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="显示绑定"><a href="#显示绑定" class="headerlink" title="显示绑定"></a>显示绑定</h2><p>通过<code>call(···)</code>或者<code>apply(···)</code>方法。第一个参数是一个对象，在调用函数时将这个对象绑定到this上。因为直接指定this的绑定对象，称之为显示绑定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ex</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ex.call(obj); <span class="comment">// 2 调用ex时强制把ex的this绑定到obj上</span></span><br></pre></td></tr></table></figure><p><strong>显示绑定无法解决丢失绑定的问题</strong></p><p>解决方案： </p><h3 id="硬绑定"><a href="#硬绑定" class="headerlink" title="硬绑定"></a>硬绑定</h3><p>创建函数bar()，并在它的内部手动调用foo.call(obj)，强制把foo的this绑定到了obj。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo.call( obj );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// 2</span></span><br><span class="line">setTimeout( bar, <span class="number">100</span> ); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 硬绑定的bar不可能再修改它的this</span></span><br><span class="line">bar.call( <span class="built_in">window</span> ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>典型应用场景是创建一个包裹函数，负责接收参数并返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a, something );</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foo.apply( obj, <span class="built_in">arguments</span> );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = bar( <span class="number">3</span> ); <span class="comment">// 2 3</span></span><br><span class="line"><span class="built_in">console</span>.log( b ); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><ul><li>创建一个可以重复使用的辅助函数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a, something );</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的辅助绑定函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn, obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn.apply( obj, <span class="built_in">arguments</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = bind( foo, obj );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = bar( <span class="number">3</span> ); <span class="comment">// 2 3</span></span><br><span class="line"><span class="built_in">console</span>.log( b ); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><ul><li>ES5内置了Function.prototype.bind，bind会返回一个硬绑定的新函数，用法如下:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a, something );</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.bind( obj );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = bar( <span class="number">3</span> ); <span class="comment">// 2 3</span></span><br><span class="line"><span class="built_in">console</span>.log( b ); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h3 id="API调用的“上下文”"><a href="#API调用的“上下文”" class="headerlink" title="API调用的“上下文”"></a>API调用的“上下文”</h3><p>JS许多内置函数提供了一个可选参数，被称之为“上下文”（context），其作用和bind(..)一样，确保回调函数使用指定的this。这些函数实际上通过call(..)和apply(..)实现了显式绑定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( el, <span class="keyword">this</span>.id );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    id: <span class="string">"awesome"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// 调用foo(..)时把this绑定到obj</span></span><br><span class="line">myArray.forEach( foo, obj );</span><br><span class="line"><span class="comment">// 1 awesome 2 awesome 3 awesome</span></span><br></pre></td></tr></table></figure><h2 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h2><ul><li>在JS中，构造函数只是使用<code>new</code>操作符时被调用的普通函数，他们不属于某个类，也不会实例化一个类。</li><li>包括内置对象函数（比如<code>Number(..)</code>）在内的所有函数都可以用<code>new</code>来调用，这种函数调用被称为构造函数调用。</li><li>实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。</li></ul><p>使用<code>new</code>来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。</p><ul><li>1、创建（或者说构造）一个新对象。</li><li>2、这个新对象会被执行<code>[[Prototype]]</code>连接。</li><li>3、这个新对象会绑定到函数调用的<code>this</code>。</li><li>4、如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。</li></ul><p>使用<code>new</code>来调用<code>foo(..)</code>时，会构造一个新对象并把它<code>（bar）</code>绑定到<code>foo(..)</code>调用中的<code>this</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> foo(<span class="number">2</span>); <span class="comment">// bar和foo(..)调用中的this进行绑定</span></span><br><span class="line"><span class="built_in">console</span>.log( bar.a ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="手写一个new实现"><a href="#手写一个new实现" class="headerlink" title="手写一个new实现"></a>手写一个new实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个空的对象</span></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(),</span><br><span class="line"><span class="comment">// 获得构造函数，arguments中去除第一个参数</span></span><br><span class="line">    Con = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line"><span class="comment">// 链接到原型，obj 可以访问到构造函数原型中的属性</span></span><br><span class="line">    obj.__proto__ = Con.prototype;</span><br><span class="line"><span class="comment">// 绑定 this 实现继承，obj 可以访问到构造函数中的属性</span></span><br><span class="line">    <span class="keyword">var</span> ret = Con.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line"><span class="comment">// 优先返回构造函数返回的对象</span></span><br><span class="line"><span class="keyword">return</span> ret <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? ret : obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用这个手写的new</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用内置函数new</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(...)</span><br><span class="line">                        </span><br><span class="line"><span class="comment">// 使用手写的new，即create</span></span><br><span class="line"><span class="keyword">var</span> person = create(Person, ...)</span><br></pre></td></tr></table></figure><p>代码原理解析：</p><ul><li><p>1、用<code>new Object()</code>的方式新建了一个对象<code>obj</code></p></li><li><p>2、取出第一个参数，就是我们要传入的构造函数。此外因为 shift 会修改原数组，所以 <code>arguments</code>会被去除第一个参数</p></li><li><p>3、将 <code>obj</code>的原型指向构造函数，这样obj就可以访问到构造函数原型中的属性</p></li><li><p>4、使用<code>apply</code>，改变构造函数<code>this</code>的指向到新建的对象，这样 <code>obj</code>就可以访问到构造函数中的属性</p></li><li><p>5、返回 <code>obj</code></p></li></ul><h2 id="箭头函数绑定"><a href="#箭头函数绑定" class="headerlink" title="箭头函数绑定"></a>箭头函数绑定</h2><p>ES6新增一种特殊函数类型：箭头函数，箭头函数无法使用上述四条规则，而是根据外层（函数或者全局）作用域（词法作用域）来决定<code>this</code>。</p><ul><li><code>foo()</code>内部创建的箭头函数会捕获调用时<code>foo()</code>的<code>this</code>。由于<code>foo()</code>的<code>this</code>绑定到<code>obj1</code>，<code>bar</code>(引用箭头函数)的this也会绑定到<code>obj1</code>，箭头函数的绑定无法被修改(new也不行)。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 返回一个箭头函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// this继承自foo()</span></span><br><span class="line">        <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    a: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.call( obj1 );</span><br><span class="line">bar.call( obj2 ); <span class="comment">// 2，不是3！</span></span><br></pre></td></tr></table></figure><p>ES6之前和箭头函数类似的模式，采用的是词法作用域取代了传统的this机制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>; <span class="comment">// lexical capture of this</span></span><br><span class="line">    setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( self.a ); <span class="comment">// self只是继承了foo()函数的this绑定</span></span><br><span class="line">    &#125;, <span class="number">100</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.call(obj); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>代码风格统一问题：如果既有this风格的代码，还会使用 seft = this 或者箭头函数来否定this机制。</p><ul><li>只使用词法作用域并完全抛弃错误<code>this</code>风格的代码；</li><li>完全采用this风格，在必要时使用bind(..)，尽量避免使用 self = this 和箭头函数</li></ul><p>其实大部分情况下可以用一句话来概括，<strong>this总是指向调用该函数的对象</strong>。</p><p>但是对于箭头函数并不是这样，是根据外层（函数或者全局）作用域（<strong>词法作用域</strong>）来决定this。</p><p>对于箭头函数的<code>this</code>总结如下：</p><ul><li><p>箭头函数不绑定<code>this</code>，箭头函数中的this相当于普通变量。</p></li><li><p>箭头函数的<code>this</code>寻值行为与普通变量相同，在作用域中逐级寻找。</p></li><li><p>箭头函数的<code>this</code>无法通过<code>bind</code>，<code>call</code>，<code>apply</code>来直接修改（可以间接修改）。</p></li><li><p>改变作用域中this的指向可以改变箭头函数的this。</p></li><li><p>eg. function closure(){()=&gt;{//code }}，在此例中，我们通过改变封包环境closure.bind(another)()，来改变箭头函数this的指向。</p></li></ul><h1 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span>绑定：<span class="keyword">this</span>绑定新创建的对象，</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> foo()</span><br><span class="line"></span><br><span class="line">显示绑定<span class="keyword">this</span>：绑定指定的对象，</span><br><span class="line"><span class="keyword">var</span> bar = foo.call(obj2)</span><br><span class="line"></span><br><span class="line">隐式绑定：<span class="keyword">this</span>绑定上下文对象，</span><br><span class="line"><span class="keyword">var</span> bar = obj1.foo()</span><br><span class="line"></span><br><span class="line">默认绑定：函数体严格模式下绑定到<span class="literal">undefined</span>，否则绑定到全局对象。</span><br><span class="line"><span class="keyword">var</span> bar = foo()</span><br></pre></td></tr></table></figure><p>在new中使用硬绑定函数的目的是预先设置函数的一些参数，这样在使用new进行初始化时就可以只传入其余的参数（柯里化）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">p1, p2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.val = p1 + p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之所以使用null是因为在本例中我们并不关心硬绑定的this是什么</span></span><br><span class="line"><span class="comment">// 反正使用new时this会被修改</span></span><br><span class="line"><span class="keyword">var</span> bar = foo.bind( <span class="literal">null</span>, <span class="string">"p1"</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> bar( <span class="string">"p2"</span> );</span><br><span class="line"></span><br><span class="line">baz.val; <span class="comment">// p1p2</span></span><br></pre></td></tr></table></figure><h1 id="绑定例外"><a href="#绑定例外" class="headerlink" title="绑定例外"></a>绑定例外</h1><h2 id="被忽略的this"><a href="#被忽略的this" class="headerlink" title="被忽略的this"></a>被忽略的this</h2><p>把<code>null</code>或者<code>undefined</code>作为<code>this</code>的绑定对象传入<code>call</code>、<code>apply</code>或者<code>bind</code>，这些值在调用时会被忽略，实际应用的是默认规则。</p><p>下面两种情况下会传入<code>null</code></p><ul><li>使用<code>apply(..)</code>来“展开”一个数组，并当作参数传入一个函数</li><li><code>bind(..)</code>可以对参数进行柯里化（预先设置一些参数）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"a:"</span> + a + <span class="string">"，b:"</span> + b );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把数组”展开“成参数</span></span><br><span class="line">foo.apply( <span class="literal">null</span>, [<span class="number">2</span>, <span class="number">3</span>] ); <span class="comment">// a:2，b:3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用bind(..)进行柯里化</span></span><br><span class="line"><span class="keyword">var</span> bar = foo.bind( <span class="literal">null</span>, <span class="number">2</span> );</span><br><span class="line">bar( <span class="number">3</span> ); <span class="comment">// a:2，b:3</span></span><br></pre></td></tr></table></figure><p>总是传入<code>null</code>来忽略<code>this</code>绑定可能产生一些副作用。如果某个函数确实使用了<code>this</code>，那默认绑定规则会把this绑定到全局对象中。</p><h3 id="更安全的this"><a href="#更安全的this" class="headerlink" title="更安全的this"></a>更安全的this</h3><p>安全的做法就是传入一个特殊的对象（空对象），把this绑定到这个对象不会对你的程序产生任何副作用。</p><p>JS中创建一个空对象最简单的方法是<strong><code>Object.create(null)</code></strong>，这个和{}很像，但是并不会创建<code>Object.prototype</code>这个委托，所以比{}更空。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"a:"</span> + a + <span class="string">"，b:"</span> + b );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们的空对象</span></span><br><span class="line"><span class="keyword">var</span> ø = <span class="built_in">Object</span>.create( <span class="literal">null</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把数组”展开“成参数</span></span><br><span class="line">foo.apply( ø, [<span class="number">2</span>, <span class="number">3</span>] ); <span class="comment">// a:2，b:3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用bind(..)进行柯里化</span></span><br><span class="line"><span class="keyword">var</span> bar = foo.bind( ø, <span class="number">2</span> );</span><br><span class="line">bar( <span class="number">3</span> ); <span class="comment">// a:2，b:3</span></span><br></pre></td></tr></table></figure><h2 id="间接引用"><a href="#间接引用" class="headerlink" title="间接引用"></a>间接引用</h2><p>间接引用下，调用这个函数会应用默认绑定规则。间接引用最容易在赋值时发生。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p.foo = o.foo的返回值是目标函数的引用，所以调用位置是foo()而不是p.foo()或者o.foo()</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">foo</span>: foo &#125;;</span><br><span class="line"><span class="keyword">var</span> p = &#123; <span class="attr">a</span>: <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">o.foo(); <span class="comment">// 3</span></span><br><span class="line">(p.foo = o.foo)(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="软绑定"><a href="#软绑定" class="headerlink" title="软绑定"></a>软绑定</h2><ul><li>硬绑定可以把this强制绑定到指定的对象（<code>new</code>除外），防止函数调用应用默认绑定规则。但是会降低函数的灵活性，使用<strong>硬绑定之后就无法使用隐式绑定或者显式绑定来修改this</strong>。</li><li><strong>如果给默认绑定指定一个全局对象和<code>undefined</code>以外的值</strong>，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显示绑定修改this的能力。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认绑定规则，优先级排最后</span></span><br><span class="line"><span class="comment">// 如果this绑定到全局对象或者undefined，那就把指定的默认对象obj绑定到this,否则不会修改this</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">Function</span>.prototype.softBind) &#123;</span><br><span class="line">    <span class="built_in">Function</span>.prototype.softBind = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> fn = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 捕获所有curried参数</span></span><br><span class="line">        <span class="keyword">var</span> curried = [].slice.call( <span class="built_in">arguments</span>, <span class="number">1</span> ); </span><br><span class="line">        <span class="keyword">var</span> bound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fn.apply(</span><br><span class="line">            (!<span class="keyword">this</span> || <span class="keyword">this</span> === (<span class="built_in">window</span> || global)) ? </span><br><span class="line">                obj : <span class="keyword">this</span>,</span><br><span class="line">                curried.concat.apply( curried, <span class="built_in">arguments</span> )</span><br><span class="line">            );</span><br><span class="line">        &#125;;</span><br><span class="line">        bound.prototype = <span class="built_in">Object</span>.create( fn.prototype );</span><br><span class="line">        <span class="keyword">return</span> bound;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：软绑定版本的foo()可以手动将this绑定到obj2或者obj3上，但如果应用默认绑定，则会将this绑定到obj。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"name:"</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">"obj"</span> &#125;,</span><br><span class="line">    obj2 = &#123; <span class="attr">name</span>: <span class="string">"obj2"</span> &#125;,</span><br><span class="line">    obj3 = &#123; <span class="attr">name</span>: <span class="string">"obj3"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认绑定，应用软绑定，软绑定把this绑定到默认对象obj</span></span><br><span class="line"><span class="keyword">var</span> fooOBJ = foo.softBind( obj );</span><br><span class="line">fooOBJ(); <span class="comment">// name: obj </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式绑定规则</span></span><br><span class="line">obj2.foo = foo.softBind( obj );</span><br><span class="line">obj2.foo(); <span class="comment">// name: obj2 &lt;---- 看！！！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式绑定规则</span></span><br><span class="line">fooOBJ.call( obj3 ); <span class="comment">// name: obj3 &lt;---- 看！！！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定丢失，应用软绑定</span></span><br><span class="line">setTimeout( obj2.foo, <span class="number">10</span> ); <span class="comment">// name: obj</span></span><br></pre></td></tr></table></figure><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    num: <span class="number">2</span>,</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = <span class="number">3</span>;</span><br><span class="line">        (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.num);</span><br><span class="line">            <span class="keyword">this</span>.num = <span class="number">4</span>;</span><br><span class="line">        &#125;)();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.num);</span><br><span class="line">    &#125;,</span><br><span class="line">    sub: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObject.add();</span><br><span class="line"><span class="built_in">console</span>.log(myObject.num);</span><br><span class="line"><span class="built_in">console</span>.log(num);</span><br><span class="line"><span class="keyword">var</span> sub = myObject.sub;</span><br><span class="line">sub();</span><br></pre></td></tr></table></figure><p>答案有两种情况，分为严格模式和非严格模式。</p><ul><li>严格模式下，报错。TypeError: Cannot read property ‘num’ of undefined</li><li>非严格模式下，输出：1、3、3、4、4<br>解答过程：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    num: <span class="number">2</span>,</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = <span class="number">3</span>; <span class="comment">// 隐式绑定 修改 myObject.num = 3</span></span><br><span class="line">        (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.num); <span class="comment">// 默认绑定 输出 1</span></span><br><span class="line">            <span class="keyword">this</span>.num = <span class="number">4</span>; <span class="comment">// 默认绑定 修改 window.num = 4</span></span><br><span class="line">        &#125;)();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.num); <span class="comment">// 隐式绑定 输出 3</span></span><br><span class="line">    &#125;,</span><br><span class="line">    sub: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.num) <span class="comment">// 因为丢失了隐式绑定的myObject，所以使用默认绑定 输出 4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObject.add(); <span class="comment">// 1 3</span></span><br><span class="line"><span class="built_in">console</span>.log(myObject.num); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">var</span> sub = myObject.sub;<span class="comment">//  丢失了隐式绑定的myObject</span></span><br><span class="line">sub(); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      5种this绑定全面解析
    
    </summary>
    
      <category term="this" scheme="https://liuchuanyang65.github.io/categories/this/"/>
    
    
      <category term="this" scheme="https://liuchuanyang65.github.io/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>traverse遍历</title>
    <link href="https://liuchuanyang65.github.io/traverse/index/"/>
    <id>https://liuchuanyang65.github.io/traverse/index/</id>
    <published>2019-08-07T09:55:30.000Z</published>
    <updated>2019-08-27T11:05:31.905Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章主要讲解了遍历：深度优先遍历、广度优先遍历。</p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"parent"</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"child-1"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"child-1-1"</span>&gt;</span><br><span class="line">      &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"child-1-1-1"</span>&gt;</span><br><span class="line">        a</span><br><span class="line">      &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"child-1-2"</span>&gt;</span><br><span class="line">      &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"child-1-2-1"</span>&gt;</span><br><span class="line">        b</span><br><span class="line">      &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"child-1-3"</span>&gt;</span><br><span class="line">      c</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">  &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"child-2"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"child-2-1"</span>&gt;</span><br><span class="line">      d</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"child-2-2"</span>&gt;</span><br><span class="line">      e</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">  &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">  // 递归</span><br><span class="line">  <span class="keyword">let</span> deepTraversal1 = (<span class="type">node</span>, nodeList) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="type">node</span>) &#123;</span><br><span class="line">      nodeList.push(<span class="type">node</span>)</span><br><span class="line">      <span class="keyword">let</span> children = <span class="type">node</span>.children</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.length; i++ ) &#123;</span><br><span class="line">        deepTraversal1(children[i], nodeList)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nodeList</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> deepTraversal2 = (<span class="type">node</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> nodes = []</span><br><span class="line">    <span class="keyword">if</span> (!<span class="type">node</span>) &#123;</span><br><span class="line">      nodes.push(<span class="type">node</span>)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">        nodes = nodes<span class="built_in">.concat</span>(deepTraversal2(children[i]))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nodes</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 非递归</span><br><span class="line"><span class="keyword">let</span> deepTraversal3 = (<span class="type">node</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> stack = []</span><br><span class="line">  <span class="keyword">let</span> nodes = []</span><br><span class="line">  <span class="keyword">if</span> (<span class="type">node</span>) &#123;</span><br><span class="line">    // 推入当前处理的<span class="type">node</span></span><br><span class="line">    stack.push(<span class="type">node</span>)</span><br><span class="line">    while (stack.length) &#123;</span><br><span class="line">      <span class="keyword">let</span> <span class="type">item</span> = stack.pop() // 取出最后一个元素</span><br><span class="line">      <span class="keyword">let</span> children = <span class="type">item</span>.children</span><br><span class="line">      nodes.push(<span class="type">item</span>)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = children.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        stack.push(children[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nodes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="深度优先遍历结果如下"><a href="#深度优先遍历结果如下" class="headerlink" title="深度优先遍历结果如下"></a>深度优先遍历结果如下</h4><pre><code>0: div.parent1: div.child-12: div.child-1-13: div.child-1-1-14: div.child-1-25: div.child-1-2-16: div.child-1-37: div.child-28: div.child-2-19: div.child-2-2</code></pre><h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> widthTraversal = (node) =&gt; &#123;</span><br><span class="line">  <span class="built_in">let</span> stack = []</span><br><span class="line">  <span class="built_in">let</span> nodes = []</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    stack.<span class="built_in">push</span>(node)</span><br><span class="line">    <span class="keyword">while</span>(stack.<span class="built_in">length</span>) &#123;</span><br><span class="line">      <span class="built_in">let</span> item = stack.shift() // 取第一个 先进先出</span><br><span class="line">      <span class="built_in">let</span> children = item.children</span><br><span class="line">      nodes.<span class="built_in">push</span>(item)</span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">let</span> i = children.<span class="built_in">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        stack.<span class="built_in">push</span>(children[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> nodes</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="广度优先遍历结果如下"><a href="#广度优先遍历结果如下" class="headerlink" title="广度优先遍历结果如下"></a>广度优先遍历结果如下</h4><p>0: div.parent<br>1: div.child-2<br>2: div.child-1<br>3: div.child-2-2<br>4: div.child-2-1<br>5: div.child-1-3<br>6: div.child-1-2<br>7: div.child-1-1<br>8: div.child-1-2-1<br>9: div.child-1-1-1</p>]]></content>
    
    <summary type="html">
    
      本篇文章主要讲解了遍历：深度优先遍历、广度优先遍历
    
    </summary>
    
      <category term="前端面试" scheme="https://liuchuanyang65.github.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端面试" scheme="https://liuchuanyang65.github.io/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>createReact</title>
    <link href="https://liuchuanyang65.github.io/createReact/index/"/>
    <id>https://liuchuanyang65.github.io/createReact/index/</id>
    <published>2019-08-06T09:44:58.000Z</published>
    <updated>2019-08-27T11:09:25.401Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章主要介绍了react（16）+antd+less+axios 搭建框架时所遇到的问题。可供新手创建项目时参考。</p><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h3 id="1、使用create-react-app-创建一个react应用"><a href="#1、使用create-react-app-创建一个react应用" class="headerlink" title="1、使用create-react-app 创建一个react应用"></a>1、使用create-react-app 创建一个react应用</h3><ul><li>官网有详细介绍：<a href="https://zh-hans.reactjs.org/docs/create-a-new-react-app.html" target="_blank" rel="noopener">https://zh-hans.reactjs.org/docs/create-a-new-react-app.html</a><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">yarn </span><span class="built_in">create-react-app</span> <span class="string">my-app</span></span><br><span class="line"><span class="string">cd </span><span class="string">my-app</span></span><br><span class="line"><span class="string">yarn </span><span class="string">start</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2、将webpack配置进行对外暴露"><a href="#2、将webpack配置进行对外暴露" class="headerlink" title="2、将webpack配置进行对外暴露"></a>2、将webpack配置进行对外暴露</h3><p><strong>建议创建好react 项目以后就将配置进行暴露，以免后续造成一些不必要的影响</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">yarn ejct</span></span><br></pre></td></tr></table></figure><ul><li>使用yarn eject 进行配置暴露后<br>package.json 文件中也会自动展示一些依赖<br><img src="/createReact/index/ejectAfter.png" alt="使用yarn eject 进行配置暴露后"></li></ul><h3 id="2、安装antd"><a href="#2、安装antd" class="headerlink" title="2、安装antd"></a>2、安装antd</h3><ul><li>详见官网：<br><a href="https://ant.design/docs/react/use-with-create-react-app-cn" target="_blank" rel="noopener">https://ant.design/docs/react/use-with-create-react-app-cn</a></li></ul><h3 id="3、安装less"><a href="#3、安装less" class="headerlink" title="3、安装less"></a>3、安装less</h3><ul><li><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add <span class="keyword">less</span> <span class="keyword">less</span>-loader</span><br></pre></td></tr></table></figure></li><li><p>安装完成后，在config/webpack.config.js 进行less配置<br><img src="/createReact/index/lessConfig.png" alt="配置less文件"><br>两者均可 第一种相对比较简单， 第二种还需进行如下配置<br><img src="/createReact/index/lessConfig1.png" alt="配置less文件"><br><img src="/createReact/index/lessConfig2.png" alt="配置less文件"><br>如果使用了antd 在对根目录中的config-overrides.js进行配置时一定要加上下面的配置：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="keyword">override</span>, fixBabelImports, addLessLoader &#125; = require(<span class="string">'customize-cra'</span>);</span><br><span class="line"></span><br><span class="line">module.exports = <span class="keyword">override</span>(</span><br><span class="line">  fixBabelImports(<span class="string">'import'</span>, &#123;</span><br><span class="line">    libraryName: <span class="string">'antd'</span>,</span><br><span class="line">    libraryDirectory: <span class="string">'es'</span>,</span><br><span class="line">    style: <span class="string">'css'</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">  addLessLoader(&#123; <span class="comment">// 添加lessloader 如果没有.less文件无法解析</span></span><br><span class="line">    javascriptEnabled: <span class="literal">true</span>,</span><br><span class="line">    modifyVars: &#123;<span class="string">'@primary-color'</span>: <span class="string">'#1DA57A'</span>&#125;, <span class="comment">// 定义主题色</span></span><br><span class="line">  &#125;),</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h3 id="4、axios-配置全局环境变量-本地跨域反向代理"><a href="#4、axios-配置全局环境变量-本地跨域反向代理" class="headerlink" title="4、axios(配置全局环境变量 + 本地跨域反向代理)"></a>4、axios(配置全局环境变量 + 本地跨域反向代理)</h3><ul><li>在根目录下创建 .env.****的文件 本地为 .env.development 并在文件中创建全局环境变量 必须以REACT_APP_开头 如下：<br><img src="/createReact/index/variable.png" alt="配置全局环境变量"></li></ul><p><strong>在项目的其他文件中可以process.env.REACT_APP_**的形式引用，可根据不同的环境创建不同的文件并对相关值进行配置</strong></p><ul><li>http-proxy-middleware<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn <span class="keyword">add</span><span class="bash"> http-proxy-middleware</span></span><br></pre></td></tr></table></figure></li></ul><p>在根目录下创建一个名为stepProxy.js的文件，并进行如下配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">"http-proxy-middleware"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">app</span>) </span>&#123;</span><br><span class="line">  app.use(proxy(<span class="string">"/api"</span>, &#123; </span><br><span class="line">      <span class="string">"target"</span>: <span class="string">""</span> , <span class="comment">// 你需要请求的地址 不可为空</span></span><br><span class="line">      <span class="string">"secure"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">"changeOrigin"</span>: <span class="literal">true</span>,</span><br><span class="line">      ws: <span class="literal">true</span>, <span class="comment">// proxy websockets</span></span><br><span class="line">      pathRewrite: &#123;</span><br><span class="line">        <span class="string">'^/api'</span>: <span class="string">'/'</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      本篇文章主要介绍了react（16）+antd+less+axios 搭建框架时所遇到的问题。可供新手创建项目时参考。
    
    </summary>
    
      <category term="React" scheme="https://liuchuanyang65.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://liuchuanyang65.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>搭建个人博客</title>
    <link href="https://liuchuanyang65.github.io/other/index/"/>
    <id>https://liuchuanyang65.github.io/other/index/</id>
    <published>2019-07-26T15:26:44.000Z</published>
    <updated>2019-12-02T11:09:24.438Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章主要讲了我在搭建个人博客时遇到的一些问题，以及使用github + hexo 搭建个人博客的大致方向，希望可以帮助到有需要的人。</p><h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><h3 id="1、使用GitHub-账号创建一个new-repository"><a href="#1、使用GitHub-账号创建一个new-repository" class="headerlink" title="1、使用GitHub 账号创建一个new repository"></a>1、使用GitHub 账号创建一个new repository</h3><p><img src="/other/index/createRepository.png" alt="create a new repository"></p><ul><li><strong>重点</strong>： 创建new repository 的 name 格式必须为{userName}.github.io， 其中userName为github账号的用户名 </li></ul><h3 id="2、拉代码创建index-html"><a href="#2、拉代码创建index-html" class="headerlink" title="2、拉代码创建index.html"></a>2、拉代码创建index.html</h3><ul><li>将github的代码down 下来 然后创建一个index.html 并先输入一些内容进行相关显示用于后续检查是否创建并上传成功成功</li><li>创建好后 提交代码 便可以访问 <a href="http://userName.github.io" target="_blank" rel="noopener">http://userName.github.io</a> 检查是否成功</li></ul><h3 id="3、HEXO"><a href="#3、HEXO" class="headerlink" title="3、HEXO"></a>3、HEXO</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init <span class="comment">// 创建一个空文件并使用hexo 初始化</span></span><br><span class="line">hexo <span class="keyword">new</span> [layout] &lt;title&gt;  <span class="comment">// 创建一个新文件</span></span><br><span class="line">hexo <span class="keyword">server</span> <span class="comment">// 运行hexo</span></span><br></pre></td></tr></table></figure><ul><li>具体命令可详见官网 <a href="https://hexo.io/docs/commands" target="_blank" rel="noopener">https://hexo.io/docs/commands</a></li><li>还可对一些基本配置进行修改 文件： _config.yml</li><li>可以在官网选择自己喜欢的主题 进入相对应的github 地址进行clone  然后在hexo文件进行安装 npm install <em>****.git</em> 会相对应生成一个主题文件 需要在<em>_config.yml</em> 将 <em>theme</em> 属性修改为新安装的主题名称</li></ul><h3 id="4、-hexo-与-github-进行连接"><a href="#4、-hexo-与-github-进行连接" class="headerlink" title="4、 hexo 与 github 进行连接"></a>4、 hexo 与 github 进行连接</h3><ul><li>在 <em>_config.yml</em> 中修改下列属性 repository 为github 的SSH(必须只能是SSH)、branch 为分支<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repository</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:liuchuanyang65/liuchuanyang65.github.io.git</span><br><span class="line">  <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure></li></ul><p>修改成功后 <strong>hexo d -g</strong> 即可直接上传到github 并可查看<a href="http://userName.github.io" target="_blank" rel="noopener">http://userName.github.io</a> 观察效果</p><h3 id="5、-在-hexo-编辑中上传本地图片"><a href="#5、-在-hexo-编辑中上传本地图片" class="headerlink" title="5、 在 hexo 编辑中上传本地图片"></a>5、 在 hexo 编辑中上传本地图片</h3><ul><li><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https:<span class="regexp">//gi</span>thub.com<span class="regexp">/CodeFalling/</span>hexo-asset-image --save  <span class="regexp">//</span> 安装插件</span><br></pre></td></tr></table></figure></li><li><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n other <span class="comment">// 新建一个other的文件 同时会生成一个other文件夹 将图片放置在other文件夹即可</span></span><br></pre></td></tr></table></figure></li><li><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">图片无法加载时显示的文案</span>](<span class="link">文件夹名/图片名</span>) // 引入图片格式</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      本篇文章详细介绍了如何使用github + hexo搭建个人博客的详细步骤, 可供参考。
    
    </summary>
    
      <category term="github" scheme="https://liuchuanyang65.github.io/categories/github/"/>
    
    
      <category term="github" scheme="https://liuchuanyang65.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>hexo的基本命令</title>
    <link href="https://liuchuanyang65.github.io/hello-world/"/>
    <id>https://liuchuanyang65.github.io/hello-world/</id>
    <published>2019-07-25T07:21:08.900Z</published>
    <updated>2019-07-26T06:16:16.561Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="杂" scheme="https://liuchuanyang65.github.io/categories/%E6%9D%82/"/>
    
    
  </entry>
  
</feed>
